#ifndef GLOBAL_H_
#define GLOBAL_H_

#include "type.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdarg.h>
#include <sys/stat.h>
#include <time.h>

#if defined OS_LINUX
#include <sys/ioctl.h>
#include <features.h>
#include <termios.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>
#include <dirent.h>
#include <fnmatch.h>
#include <poll.h>
#elif defined OS_WIN
#define _POSIX_
#include <limits.h>
#undef _POSIX_
#include <windows.h>
#endif

// generated by automake
#ifdef HAVE_CONFIG_H
#include "../config.h"
#endif

// __attribute__
#ifdef OS_WIN
#define __attribute__(unused)
#endif


#ifdef OS_ANDROID
#include <android/log.h>
#define OS_LOGD(fmt,...)	do{__android_log_print(ANDROID_LOG_DEBUG, "LOG", fmt,##__VA_ARGS__);}while(0)
#define OS_LOGE(fmt,...)	do{__android_log_print(ANDROID_LOG_ERROR, "LOG", fmt,##__VA_ARGS__);}while(0)
#else
#define OS_LOGD(fmt,...)	do{fprintf(stdout,fmt,##__VA_ARGS__);}while(0)
#define OS_LOGE(fmt,...)	do{fprintf(stderr,fmt,##__VA_ARGS__);}while(0)
#endif


#ifdef ENABLE_LOG
#define LOGD(topic,fmt,...) OS_LOGD("[%s]"fmt"\n",topic,##__VA_ARGS__)
#define LOGD_HEX(topic,data,len) do{ \
    char buf[1024]; \
    int index = 0,i; \
    index += snprintf(buf+index,sizeof(buf)-index,":\"");\
    for(i=0;i<(len);i++){\
        index += snprintf(buf+index,sizeof(buf)-index,"%02X ",(unsigned char)data[i]);\
    }\
    index += snprintf(buf+index,sizeof(buf)-index,"\"\n");\
    OS_LOGD(topic,"%s",buf);\
}while(0)
#else
#define LOGD(topic,fmt,...)
#define LOGD_HEX(topic,data,len)
#endif
#define LOGE(topic,fmt,...) OS_LOGE("[%s]"fmt" in func:%s line:%d\n",topic,##__VA_ARGS__,__FUNCTION__,__LINE__)




#define DECL_OVERRIDE
#define UNUSED(x) (void)x;

#if defined(OS_WIN)
/* strndup is not available  in windows */
/*#define strndup(data,max) \
    (char*)(char* dup_#data = (char*)malloc(max))*/
#endif

typedef struct{
    char* data;
    size_t len;
}String;
static inline String* NEW_STRING(len)
{
    String* str = (String*)malloc(sizeof(String));
    str->len = len;
    str->data =  (char*)malloc(len);
    memset(str->data,0,str->len);
    return str;
}

#define FREE_STRING(str) do{ if(str){ free(str->data); free(str); } }while(0)

#ifndef MAX
#define MAX(a,b) (a>b?a:b)
#endif
#ifndef MIN
#define MIN(a,b) (a>b?b:a)
#endif
#ifndef BOUND
#define BOUND(min,val,max)  MAX(min,MIN(max,val))
#endif

/* windows not strndup */
#ifdef OS_WIN

#endif

/* endian */

static int is_big_endian()
{
    union{
        uint16_t i;
        char c;
    }test;
    test.i = 0x0001;
    return (test.c?0:1);
}
#define IS_BIG_ENDIAN is_big_endian()

#define CHANGE_ENDIAN_16(x)     ((uint16_t)(((x&0xff)<<8)|((x&0xff00)>>8)))
#define CHANGE_ENDIAN_32(x)     ((uint32_t)(((x&0xff)<<24)|((x&0xff00)<<8)|\
                                            ((x&0xff0000)>>8)|((x&0xff000000)>>24)))
#define CHANGE_ENDIAN_64(x)     ((uint64_t)(((x&0xff)<<56)|((x&0xff00)<<40)|((x&0xff0000)<<24)|((x&0xff000000)<<8)|\
                                            ((x&0xff00000000)<<8)|((x&0xff0000000000)<<24)|((x&0xff000000000000)<<40)|((x&0xff00000000000000)<<56)))

#define TO_BIG_ENDIAN_16(x)     (IS_BIG_ENDIAN?x:CHANGE_ENDIAN_16(x))
#define TO_BIG_ENDIAN_32(x)     (IS_BIG_ENDIAN?x:CHANGE_ENDIAN_32(x))
#define TO_BIG_ENDIAN_64(x)     (IS_BIG_ENDIAN?x:CHANGE_ENDIAN_64(x))

#define UINT8_T_P(p)    ((uint8_t*)(p))
#define BIG_ENDIAN_BUF_16(p)    ((uint16_t)((*(UINT8_T_P(p))<<8) + (*(UINT8_T_P(p)+1))))
#define BIG_ENDIAN_BUF_32(p)    ((uint32_t)((*(UINT8_T_P(p))<<24) + (*(UINT8_T_P(p)+1)<<16)) + (*(UINT8_T_P(p)+2)<<8) + (*(UINT8_T_P(p)+3)))
#define BIG_ENDIAN_BUF_64(p)    ((uint64_t)((*(UINT8_T_P(p))<<56) + (*(UINT8_T_P(p)+1)<<48) + (*(UINT8_T_P(p)+2)<<40) + (*(UINT8_T_P(p)+3)<<32) + \
                                (*(UINT8_T_P(p)+4)<<24) + (*(UINT8_T_P(p)+5)<<16) + (*(UINT8_T_P(p)+6)<<8) + (*(UINT8_T_P(p)+7))))

#define TO_LITTLE_ENDIAN_16(x)  (IS_BIG_ENDIAN?CHANGE_ENDIAN_16(x):x)
#define TO_LITTLE_ENDIAN_32(x)  (IS_BIG_ENDIAN?CHANGE_ENDIAN_32(x):x)
#define TO_LITTLE_ENDIAN_64(x)  (IS_BIG_ENDIAN?CHANGE_ENDIAN_64(x):x)

#define TO_LITTLE_ENDIAN(x) \
    do{\
        int bytes = sizeof(x);\
        if(bytes==2)\
            x = TO_LITTLE_ENDIAN_16(x);\
        else if(bytes==4)\
            x = TO_LITTLE_ENDIAN_32(x);\
        else if(bytes==8)\
            x = TO_LITTLE_ENDIAN_64(x);\
    }while(0)

#define TO_BIG_ENDIAN(x) \
    do{\
        int bits = sizeof(x);\
        if(bits==2)\
            x = TO_BIG_ENDIAN_16(x);\
        else if(bits==4)\
            x = TO_BIG_ENDIAN_32(x);\
        else if(bits==8)\
            x = TO_BIG_ENDIAN_64(x);\
    }while(0)
/* file */
/* for HANDLE */
#ifndef OS_WIN
typedef int HANDLE;
#   ifndef INVALID_HANDLE_VALUE
#   define INVALID_HANDLE_VALUE -1
#   endif
#define IS_HANDLE_VALID(handle) (handle>0)
#else
#define IS_HANDLE_VALID(handle) (handle!=INVALID_HANDLE_VALUE)
#endif

#if defined OS_LINUX
#define os_open(file)                   open(file,O_RDWR)
#define os_close(handle)                close(handle);
#define os_read(handle,buf,max,ret)     do{ret = read(handle,buf,max);}while(0)
#define os_write(handle,buf,max,ret)    do{ret = write(handle,buf,max);}while(0)
#define os_select(rfd,wfd,ms,ret)       \
    do{\
        fd_set rset,wset;\
        HANDLE nfds = 0;\
        struct timeval timeout;\
        FD_ZERO(&rset);FD_ZERO(&wset);\
        if(rfd!=INVALID_HANDLE_VALUE){FD_SET(rfd,&rset);nfds = MAX(nfds,rfd);}\
        if(wfd!=INVALID_HANDLE_VALUE){FD_SET(wfd,&wset);nfds = MAX(nfds,wfd);}\
        if((ms)>=0){timeout.tv_sec = (ms)/1000L;timeout.tv_usec = (ms)%1000*1000L;}\
        ret = select(nfds+1,&rset,&wset,NULL,(((ms)>=0)?&timeout:NULL));\
    }while(0)
#define os_seek(handle,offset)		do{lseek(handle,offset,SEEK_CUR);}while(0)
#elif defined OS_WIN
#define os_open(file)       CreateFile(file,GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)
#define os_close(handle)                CloseHandle(handle);
#define os_read(handle,buf,max,ret)     ReadFile(handle, buf, (DWORD)max, &ret, NULL);
#define os_write(handle,buf,max,ret)    WriteFile(handle, buf, (DWORD) max, &ret, NULL);
#define os_select(rfd,wfd,ms,ret)		do{ret=FALSE;}while(0)
#define os_seek(handle,offset)		do{SetFilePointer(handle,offset,NULL,FILE_CURRENT);}while(0)
#endif

/* thread and mutex */
#if defined OS_LINUX
#include <pthread.h>
#define os_thread_t     pthread_t
typedef void* (*os_thread_cb_t)(void *args);
#define os_thread_join(thread)					do{pthread_join(thread,NULL);}while(0)
#define os_thread_create(thread,func,args)      do{pthread_create(&thread,NULL,func,args);}while(0)

#define os_mutex_t      pthread_mutex_t

#define os_mutex_init(mutex)    \
    do{\
        pthread_mutexattr_t attr;\
        pthread_mutexattr_init(&attr);\
        pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_RECURSIVE_NP);\
        pthread_mutex_init(&mutex,&attr);\
        pthread_mutexattr_destroy(&attr);\
    }while(0)
#define os_mutex_lock(mutex)    pthread_mutex_lock(&mutex)
#define os_mutex_unlock(mutex)  pthread_mutex_unlock(&mutex)
#define os_mutex_trylock(mutex)	(pthread_mutex_trylock(&mutex)==0)
#define os_mutex_destroy(mutex)    pthread_mutex_destroy(&mutex)

#define os_cond_t       pthread_cond_t
#define os_cond_init(cond)          pthread_cond_init(&cond,NULL)
#define os_cond_destroy(cond)       pthread_cond_destroy(&cond)
#define os_cond_signal(cond)        pthread_cond_signal(&cond)
#define os_cond_broadcast(cond)     pthread_cond_broadcast(&cond)
#define os_cond_wait(cond,mutex)    pthread_cond_wait(&cond,&mutex)

//# ifdef __USE_POSIX199309
#if 0
#define os_cond_timedwait(cond,mutex,ms,res)	do{ \
        struct timespec ts; \
        clock_gettime(CLOCK_REALTIME, &ts); \
        ts.tv_sec += ms / 1000; \
        ts.tv_nsec += (ms % 1000) * 1000000; \
        if (ts.tv_nsec >= 1000000000L) { \
            ts.tv_sec++; \
            ts.tv_nsec -= 1000000000L; \
        } \
        res = pthread_cond_timedwait(&cond,&mutex,&ts); \
        }while(0)
#else
#define os_cond_timedwait(cond,mutex,ms,res)	do{ \
        struct timespec ts; \
        struct timeval tv;\
        gettimeofday(&tv,NULL);\
        ts.tv_sec = tv.tv_sec + (ms)/1000; \
        ts.tv_nsec = tv.tv_usec*1000+((ms)%1000)*1000000; \
        if (ts.tv_nsec >= 1000000000L) { \
            ts.tv_sec++; \
            ts.tv_nsec -= 1000000000L; \
        } \
        res = pthread_cond_timedwait(&cond,&mutex,&ts); \
        }while(0)
#endif

#elif defined OS_WIN

#include <winbase.h>
#include <process.h>
#define os_thread_t     HANDLE
#define os_thread_cb_t	LPTHREAD_START_ROUTINE
#define os_thread_join(thread)					WaitForSingleObject(thread,INFINITE)
#define os_thread_create(thread,func,args)		thread = CreateThread(NULL,NULL,func,args,NULL,NULL)

#define os_mutex_t      CRITICAL_SECTION	
#define os_mutex_init(mutex)		InitializeCriticalSection(&mutex)	
#define os_mutex_lock(mutex)		EnterCriticalSection(&mutex)	
#define os_mutex_unlock(mutex)		LeaveCriticalSection(&mutex)	
#define os_mutex_trylock(mutex)		TryEnterCriticalSection(&mutex)
#define os_mutex_destroy(mutex)		DeleteCriticalSection(&mutex)	

#define	ETIMEDOUT	110	

#define os_cond_t      CONDITION_VARIABLE
#define os_cond_init(cond)			InitializeConditionVariable(&cond)
#define os_cond_destroy(cond)       
#define os_cond_signal(cond)		WakeConditionVariable(&cond)
#define os_cond_broadcast(cond)		WakeAllConditionVariable(&cond)
#define os_cond_wait(cond,mutex)    SleepConditionVariableCS(&cond,&mutex,INFINITE)
#define os_cond_timedwait(cond,mutex,ms,res)	do{ \
			if(SleepConditionVariableCS(&cond,&mutex,ms) \
				res=0; \
			else if(GetLastError()==WAIT_TIMEOUT) \
				res = ETIMEDOUT; \
			else \
				res = -1; \
			}while(0)
#endif

/* error */
#if defined OS_LINUX
#define os_error strerror(errno)
#define os_errno errno
#elif defined OS_WIN
#define os_error
#define os_errno GetLastError()
#endif
#endif /* GLOBAL_H_ */
